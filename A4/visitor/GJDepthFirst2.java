//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class GJDepthFirst2<R,A> implements GJVisitor<R,A> { 

    int[] numberOfRegisterAllocated = new int[4];

    public class CFG{

        HashMap<Integer, HashMap<String,Integer>> functionInfo;

        CFG(){
            functionInfo = new HashMap<Integer, HashMap<String,Integer>>();
            functionInfo.put(0, new  HashMap<String,Integer>()); 
            functionInfo.put(1, new  HashMap<String,Integer>());
            functionInfo.put(2, new  HashMap<String,Integer>());
            functionInfo.put(3, new  HashMap<String,Integer>());
            functionInfo.put(4, new  HashMap<String,Integer>());
            functionInfo.put(5, new  HashMap<String,Integer>());

        }
        int SpillCount;
        HashMap<String,HashMap<Integer, RegisterAllocation> > registermapping;
    };

    public class userDefined{
        HashMap<Integer,Set<Integer>> SourceDestination;
        userDefined(){
             SourceDestination = new HashMap<Integer,Set<Integer>> ();
             SourceDestination.put(0,new HashSet<Integer> ());
             SourceDestination.put(1,new HashSet<Integer> ());
             SourceDestination.put(2,new HashSet<Integer> ());
             SourceDestination.put(3,new HashSet<Integer> ());

        }
    };
    public class RegisterAllocation{
       int StackRegister;
       String GeneralRegister;
       boolean registerLock;
    };

   int [] MaximumcalledList = {0,0,0,0,0,0,0,0,0,0};

   HashMap<Integer,String> checkerTo = new HashMap<Integer,String> ();
   HashMap<String,Integer> checkingForTemporarires = new HashMap<String,Integer> ();

   HashMap<Integer,HashMap<String,Integer>> argumentsCountForFunction = new HashMap<Integer,HashMap<String,Integer>> ();
   
   int [] usedForChecking = new int[10];

   HashMap<String,HashMap<Integer, RegisterAllocation> > registermapping = new HashMap<String,HashMap<Integer, RegisterAllocation> >();
   HashMap < String,Integer> labelInstruction;

   HashMap <Integer, HashMap <Integer, Set<Integer> >> variableInfo = new HashMap <Integer, HashMap <Integer, Set<Integer> >> () ; 

   //
   // Auto class visitors--probably don't need to be overridden.
   //
   public R visit(NodeList n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n, A argu) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         LinkedList<R> l = new LinkedList<R>();
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            l.add(e.nextElement().accept(this,argu));
            _count++;
         }
         return (R) l;
      }
      else
         return null;
   }

   public R visit(NodeOptional n, A argu) {
      if ( n.present() ){
         return (R)(n.node.accept(this,argu));
      }
      else
         return null;
   }

   public R visit(NodeSequence n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n, A argu) { return null; }

   public int intervalEndsFindingStep(List<IntervalsOflive> Rangingoflive,liveAnalysis intervalFinding){

     Set<Integer> allVariablesNumber = intervalFinding.liveStartpoint.keySet();
     for(Integer l : allVariablesNumber){
         IntervalsOflive b = new IntervalsOflive();
         b.end = intervalFinding.liveEndpoint.get(l);
         b.start = intervalFinding.liveStartpoint.get(l);
         b.temporaryNumber = l;
         Rangingoflive.add(b);
     }
     int length = allVariablesNumber.size();
     return length;
 }

   //
   // User-generated visitor methods below
   //
 IntervalsOflive spill = new IntervalsOflive();

void NoMore(int i, List<IntervalsOflive> Rangingoflive, List<IntervalsOflive> active){
         RegisterAllocation temp = new RegisterAllocation ();
         temp.registerLock = false;
         temp.StackRegister = numberOfRegisterAllocated[2]++;
         
         Correspondence_Global.put(Rangingoflive.get(i).temporaryNumber,Correspondence_Global.get(spill.temporaryNumber));
         Correspondence_Global.put(spill.temporaryNumber, temp);
         active.remove(spill);
 
         int j = 0;
         while(j<active.size()){
               if(Rangingoflive.get(i).end<active.get(j).end){
                  break;
               }
               j++;
         }
         active.add(j,Rangingoflive.get(i));   
}

HashMap<Integer,String> registerSignature = new HashMap<Integer,String> ();
void creatingRegisterPool(){
         for(int i = 0;i<8;i++){
               registerSignature.put(i,"s"+i);
        }
        for(int i = 0;i<10;i++){
               registerSignature.put((i+8),"t"+i);
        }
}

 void spillingAtinterval(List<IntervalsOflive> Rangingoflive,int i,List<IntervalsOflive> active){
    spill = active.get(active.size()-1);
    if( spill.end > Rangingoflive.get(i).end){
        NoMore(i, Rangingoflive, active);
    }
    else{
         RegisterAllocation temp = new RegisterAllocation ();
         temp.registerLock = false;
         temp.StackRegister = numberOfRegisterAllocated[2]++;
         Correspondence_Global.put(Rangingoflive.get(i).temporaryNumber,temp);
    }
 }

 HashMap<Integer, RegisterAllocation> Correspondence_Global = new HashMap<Integer, RegisterAllocation>();

 public void newFunction(int begin,int endingInstruction,liveAnalysis intervalFinding){
        int pro1 = 1,pro2 = 0;
        while(!(pro1==0 && pro2 == 0)){
            pro1 = 0;pro2 = 0;

            int iter = begin;
            while(iter<=endingInstruction){

                 pro2 += intervalFinding.out.get(iter).size();
                 pro1 += intervalFinding.in.get(iter).size();

                  MaximumcalledList[5] = pro1;
                  MaximumcalledList[5] += pro2;

                 Set<Integer> thop1 = new HashSet<Integer> (intervalFinding.out.get(iter));
                 thop1.removeAll(variableInfo.get(1).get(iter));
                 thop1.addAll(variableInfo.get(2).get(iter));

                 MaximumcalledList[5] = pro1;

                 intervalFinding.in.put(iter,thop1);

                 Set<Integer> thop2 = new HashSet<Integer> ();

                 for(Integer i : variableInfo.get(0).get(iter)){
                     if(i!=-1){
                         thop2.addAll(intervalFinding.in.get(i));
                      }
                 }

                 intervalFinding.out.put(iter,thop2);

                 pro1 -= intervalFinding.in.get(iter).size();
                 pro2 -= intervalFinding.out.get(iter).size();

                 iter++;
            }
              
        }
 }

 void RemoveOldIntervals(Vector<Integer> poolOfRegisters,int startpoint,List<IntervalsOflive> active,HashMap<Integer, RegisterAllocation> Correspondence){
    int p = 0;
    while(p<active.size()){
        if(active.get(p).end >= startpoint){
          return;
        }
        String ans = Correspondence.get(active.get(p).temporaryNumber).GeneralRegister;
        int ok = 17;
        for(int k=0;k<8;k++){
          if(ans.equals("s"+k)){
            ok = k;
            break;
          }
       }
       for(int k=0;k<10;k++){
          if(ans.equals("t"+k)){
            ok = k+8;
            break;
          }
       }
       poolOfRegisters.add(ok);
       active.remove(p);
    }
 }

   /**
    * f0 -> "MAIN"
    * f1 -> StmtList()
    * f2 -> "END"
    * f3 -> ( Procedure() )*
    * f4 -> <EOF>
    */
   public R visit(Goal n, A argu) {

      Integer begin = 1;

      variableInfo.put(0, new HashMap<Integer, Set<Integer>>());
      variableInfo.put(1, new HashMap<Integer, Set<Integer>>());
      variableInfo.put(2, new HashMap<Integer, Set<Integer>>());

      argumentsCountForFunction.put(0,new HashMap<String,Integer>());
      argumentsCountForFunction.put(1,new HashMap<String,Integer>());
      argumentsCountForFunction.put(2,new HashMap<String,Integer>());

      labelInstruction = (HashMap < String,Integer>) argu;


      R _ret=null;

      String CurrentRunningName = "MAIN";

      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);

      argumentsCountForFunction.get(0).put(CurrentRunningName,MaximumcalledList[0]);
      argumentsCountForFunction.get(1).put(CurrentRunningName, MaximumcalledList[1]);
   
      Integer endingInstruction = MaximumcalledList[3];

      Set<Integer> c = variableInfo.get(0).get(MaximumcalledList[3]);

      usedForChecking[0] = 2;

      c.remove(MaximumcalledList[3]+1);
 
      checkerTo.put(3,"Main");

      c.add(-1);


      liveAnalysis intervalFinding = new liveAnalysis();
      List<IntervalsOflive> Rangingoflive = new ArrayList<IntervalsOflive>();

      HashMap<Integer, RegisterAllocation> Correspondence = new HashMap<Integer,RegisterAllocation> ();

      int p = begin;

      while(p<=endingInstruction){
            intervalFinding.in.put(p,new HashSet<Integer>());
            intervalFinding.out.put(p,new HashSet<Integer>());
            p++;
      }

      newFunction(begin,endingInstruction,intervalFinding);

      intervalFinding.rangeCalculation(begin,endingInstruction,intervalFinding,variableInfo);

      numberOfRegisterAllocated[0] = 0;
      numberOfRegisterAllocated[1] = 0; 
      numberOfRegisterAllocated[2] = 0;

      int siz = intervalEndsFindingStep(Rangingoflive,intervalFinding);
      Collections.sort(Rangingoflive);

      Correspondence_Global = Correspondence;

      MaximumcalledList[2] += linearScanAlgorithm(Rangingoflive,siz);

      Correspondence = Correspondence_Global;

      registermapping.put(CurrentRunningName, Correspondence);
      argumentsCountForFunction.get(2).put(CurrentRunningName, numberOfRegisterAllocated[2]);

      n.f3.accept(this, argu);
 
      String finallabDef = checkerTo.get(0);

      n.f4.accept(this, argu);
      
      CFG pass = new CFG();

      //int finalnametoget = checkingForTemporarires.get("Main");


      pass.SpillCount = MaximumcalledList[2];
      MaximumcalledList[2]++;

      for(int q = 0;q <3;q++){
         usedForChecking[q] = -1;
      }

      pass.registermapping = registermapping;

      pass.functionInfo.put(0,argumentsCountForFunction.get(0));
      pass.functionInfo.put(1,argumentsCountForFunction.get(1));
      pass.functionInfo.put(2,argumentsCountForFunction.get(2));

      return (R)pass;
   }

   int linearScanAlgorithm(List<IntervalsOflive> Rangingoflive,int size){

    Integer numberofspilledRegisters = 0;
    creatingRegisterPool();
    Vector<Integer> poolOfRegisters = new Vector<Integer> ();
    int p;
    int AlreadyAllocatedRegisters = 18-numberOfRegisterAllocated[0];
    for(int i=numberOfRegisterAllocated[0];i<18;i++){
        poolOfRegisters.add(i);
    }

    List<IntervalsOflive> active = new ArrayList<IntervalsOflive> ();

    int i=0;
    while(i < size){
       int hi = Rangingoflive.get(i).start;
       RemoveOldIntervals(poolOfRegisters,hi,active,Correspondence_Global);
       if(active.size() != AlreadyAllocatedRegisters){
          int length = poolOfRegisters.size();
          int x = poolOfRegisters.get(length-1);

          poolOfRegisters.removeElementAt(length-1);

          RegisterAllocation temp = new RegisterAllocation();
          temp.registerLock = true;

          temp.GeneralRegister = registerSignature.get(x);

          Correspondence_Global.put(Rangingoflive.get(i).temporaryNumber, temp);
          
          p = 0;
          while(p < active.size()){
            if(active.get(p).end>Rangingoflive.get(i).end){
                  break;
                } 
            p++;
          }
           active.add(p,Rangingoflive.get(i));
       }
       else{
         numberofspilledRegisters++;
          spillingAtinterval(Rangingoflive,i,active);
       }
      i++;
    }
    return numberofspilledRegisters;    
 }

   /**
    * f0 -> ( ( Label() )? Stmt() )*
    */
   public R visit(StmtList n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Label()
    * f1 -> "["
    * f2 -> IntegerLiteral()
    * f3 -> "]"
    * f4 -> StmtExp()
    */
   public R visit(Procedure n, A argu) {
      R _ret=null;

      Integer begin = ++MaximumcalledList[3];
      usedForChecking[0] = 4;

      variableInfo.get(2).put(MaximumcalledList[3],new HashSet<Integer>());
      variableInfo.get(1).put(MaximumcalledList[3],new HashSet<Integer>());

      MaximumcalledList[0]=0;
      MaximumcalledList[1]=0;

      Set<Integer> tt = new HashSet<Integer> ();
 
       usedForChecking[0] = 4;

      tt.add(MaximumcalledList[3]+1);

      variableInfo.get(0).put(MaximumcalledList[3],tt);


      String CurrentRunningName = (String)n.f0.accept(this, argu);
      n.f1.accept(this, argu);

      String pro = (String)n.f2.accept(this, argu);
      Integer countingparameters = Integer.parseInt(pro);

      n.f3.accept(this, argu);
      n.f4.accept(this, argu);

      Integer endingInstruction = MaximumcalledList[3];

      argumentsCountForFunction.get(1).put(CurrentRunningName, MaximumcalledList[1]);
      argumentsCountForFunction.get(0).put(CurrentRunningName,MaximumcalledList[0]);

       liveAnalysis intervalFinding = new liveAnalysis();
       List<IntervalsOflive> Rangingoflive = new ArrayList<IntervalsOflive>();

      HashMap<Integer, RegisterAllocation> Correspondence = new HashMap<Integer,RegisterAllocation> ();

        int p = begin;
        while(p <= endingInstruction){
            intervalFinding.in.put(p,new HashSet<Integer>());
            intervalFinding.out.put(p,new HashSet<Integer>());
            p++;
        }

        
      newFunction(begin,endingInstruction,intervalFinding);

      intervalFinding.rangeCalculation(begin,endingInstruction,intervalFinding,variableInfo); 

    numberOfRegisterAllocated[0] = 0;
    numberOfRegisterAllocated[1] = 0; 
    numberOfRegisterAllocated[2] = 0;

    int k = 0;

    while(k<countingparameters){
       if(k >= 4){
         RegisterAllocation thop2 = new RegisterAllocation();
         thop2.StackRegister= numberOfRegisterAllocated[2]++;
         thop2.registerLock = false;
         Correspondence.put(k,thop2);  
       }
       else{
            RegisterAllocation thop1 = new RegisterAllocation();
            thop1.GeneralRegister ="s"+numberOfRegisterAllocated[0];
            thop1.registerLock = true;
            Correspondence.put(k, thop1);
            numberOfRegisterAllocated[0]++;
      }
      intervalFinding.liveStartpoint.remove(k);
      intervalFinding.liveEndpoint.remove(k);
      k++;
    }

    numberOfRegisterAllocated[2] += 18;

    String finalone = CurrentRunningName;

    int size = intervalEndsFindingStep(Rangingoflive,intervalFinding);

    for(int q = 0;q<3;q++){
      usedForChecking[q] = -1;
    }

    Collections.sort(Rangingoflive);

    Correspondence_Global = Correspondence;
 

    MaximumcalledList[2] += linearScanAlgorithm(Rangingoflive,size); 

    Correspondence = Correspondence_Global;

    argumentsCountForFunction.get(2).put(CurrentRunningName, numberOfRegisterAllocated[2]);

    registermapping.put(CurrentRunningName, Correspondence);

    if(finalone.equals("MaIn")){
      System.out.println("ERROR");
    }

    return _ret;
}

   /**
    * f0 -> NoOpStmt()
    *       | ErrorStmt()
    *       | CJumpStmt()
    *       | JumpStmt()
    *       | HStoreStmt()
    *       | HLoadStmt()
    *       | MoveStmt()
    *       | PrintStmt()
    */
   public R visit(Stmt n, A argu) {

      R _ret=null;

      usedForChecking [0] = 4;

      //checkerTo.put(CurrentRunningName,usedForChecking[1]);

      userDefined b = new userDefined();
      Set<Integer> temp = new HashSet<Integer>();

       b.SourceDestination.put(0,temp);
       b.SourceDestination.put(1,temp);

       usedForChecking[1] = MaximumcalledList[3];

      variableInfo.get(2).put(MaximumcalledList[3]+1,temp);
      variableInfo.get(1).put(MaximumcalledList[3]+1,temp);

      MaximumcalledList[3]++;

      if(usedForChecking[0]==2){
          checkingForTemporarires.put("Main",2);
      }

      argu=(A)b;

      n.f0.accept(this, argu);

      /*if(usedForChecking[0]==2){
         checkingForTemporarires.put(CurrentRunningName,2);
      }*/

      return _ret;
   }

   /**
    * f0 -> "NOOP"
    */
   public R visit(NoOpStmt n, A argu) {
      R _ret=null;

      if(usedForChecking[5]==3){
          checkingForTemporarires.put("v0",3);
      }

      Set<Integer> thop = new HashSet<Integer> ();

      usedForChecking[0] = 4;

      thop.add(MaximumcalledList[3]+1);

      usedForChecking[1] = MaximumcalledList[2];

      variableInfo.get(0).put(MaximumcalledList[3],thop);


      n.f0.accept(this, argu);

      if(usedForChecking[0] == 2){
         checkerTo.put(MaximumcalledList[3],"Main");
      }

      return _ret;
   }

   /**
    * f0 -> "ERROR"
    */
   public R visit(ErrorStmt n, A argu) {
      R _ret=null;

      if(usedForChecking[6]==4){
         checkingForTemporarires.put("v1",4);
      }

      Set<Integer> thop=new HashSet<Integer> ();

      usedForChecking[0] = MaximumcalledList[1];

      thop.add(MaximumcalledList[3]+1);
      variableInfo.get(0).put(MaximumcalledList[3],thop);

      n.f0.accept(this, argu);

      if(usedForChecking[7] == 2){
         checkingForTemporarires.put("Main",MaximumcalledList[3]);
      }

      return _ret;
   }

   /**
    * f0 -> "CJUMP"
    * f1 -> Temp()
    * f2 -> Label()
    */
   public R visit(CJumpStmt n, A argu) {
      R _ret=null;

      usedForChecking[4]  = 3;


      n.f0.accept(this, argu);
      String str1 = (String)n.f1.accept(this, argu);
      String str2 = (String)n.f2.accept(this, argu);

      Set<Integer> thop = new HashSet<Integer> ();

      usedForChecking[4]  = 3;

      checkingForTemporarires.put(str1,5);
      checkingForTemporarires.put(str2,4);

      thop.add(labelInstruction.get(str2));
      thop.add(MaximumcalledList[3]+1);
      
      userDefined ans=(userDefined) argu;
      variableInfo.get(0).put(MaximumcalledList[3],thop);

      usedForChecking[9]  = MaximumcalledList[2];

      int pro = Integer.parseInt(str1);

      ans.SourceDestination.get(0).add(pro);

      if(usedForChecking[5]==2){
         checkerTo.put(MaximumcalledList[3],str2);
      }
      
      return _ret;
   }

   /**
    * f0 -> "JUMP"
    * f1 -> Label()
    */
   public R visit(JumpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);

      usedForChecking[0] = 2;

      String str = (String)n.f1.accept(this, argu);
        
      checkingForTemporarires.put(str,MaximumcalledList[4]);

      Set<Integer> thop = new HashSet<Integer> ();
      
      checkerTo.put(2,str);

      thop.add(labelInstruction.get(str));
      variableInfo.get(0).put(MaximumcalledList[3],thop);

      if(usedForChecking[0]==4){
         checkingForTemporarires.put("s0",4);
      }

      return _ret;
   }

   /**
    * f0 -> "HSTORE"
    * f1 -> Temp()
    * f2 -> IntegerLiteral()
    * f3 -> Temp()
    */
   public R visit(HStoreStmt n, A argu) {
      R _ret=null;
       
      usedForChecking[1] = 2;
      Set<Integer> thop=new HashSet<Integer> ();

      checkingForTemporarires.put("s1",MaximumcalledList[3]);

      thop.add(MaximumcalledList[3]+1);

      checkingForTemporarires.put("s2",MaximumcalledList[3]+1);

      variableInfo.get(0).put(MaximumcalledList[3],thop);

      n.f0.accept(this, argu);
      String a = (String)n.f1.accept(this, argu);

      n.f2.accept(this, argu);
      String b = (String)n.f3.accept(this, argu);

      userDefined ans = (userDefined) argu;

      int pro = Integer.parseInt(b);
      ans.SourceDestination.get(0).add(pro);
 

      checkingForTemporarires.put(a,MaximumcalledList[1]);

      checkingForTemporarires.put(b,pro);

      pro = Integer.parseInt(a);
      ans.SourceDestination.get(0).add(pro);
  
       checkingForTemporarires.put(a,MaximumcalledList[1]);

      checkingForTemporarires.put(b,pro);

      checkerTo.put(pro,"s3");

      if(usedForChecking[5]==2){
         checkerTo.put(pro,b);
      }

      return _ret;
   }

   /**
    * f0 -> "HLOAD"
    * f1 -> Temp()   //HLOAD TEMP 0 TEMP 5 0
    * f2 -> Temp()
    * f3 -> IntegerLiteral()
    */
   public R visit(HLoadStmt n, A argu) {
      R _ret=null;

      usedForChecking[1] = 2;

      Set<Integer> thop = new HashSet<Integer> ();

      checkingForTemporarires.put("s4",MaximumcalledList[3]);

      thop.add(MaximumcalledList[3]+1);

      checkingForTemporarires.put("s5",MaximumcalledList[2]);

      variableInfo.get(0).put(MaximumcalledList[3],thop);

      n.f0.accept(this, argu);
      String a = (String)n.f1.accept(this, argu);
      String b = (String)n.f2.accept(this, argu);
      n.f3.accept(this, argu);

      userDefined ans = (userDefined) argu;

      int pro = Integer.parseInt(b);
      ans.SourceDestination.get(0).add(pro);
 
     checkingForTemporarires.put(a,MaximumcalledList[1]);

      checkingForTemporarires.put(b,pro);

      pro = Integer.parseInt(a);
      ans.SourceDestination.get(1).add(pro);

      checkingForTemporarires.put(b,pro);

      checkerTo.put(pro,"s3");

      if(usedForChecking[5]==2){
         checkerTo.put(pro,b);
         usedForChecking[5] = 4;
      }

      return _ret;
   }

   /**
    * f0 -> "MOVE"
    * f1 -> Temp()
    * f2 -> Exp()
    */
   public R visit(MoveStmt n, A argu) {
      R _ret = null;
      usedForChecking[5] = 2;

      Set<Integer> thop = new HashSet<Integer> ();

      checkingForTemporarires.put("v0",MaximumcalledList[2]);

      thop.add(MaximumcalledList[3]+1);

      checkingForTemporarires.put(" MOVE ",MaximumcalledList[3]);

      variableInfo.get(0).put(MaximumcalledList[3],thop);
      n.f0.accept(this, argu);

      String a = (String)n.f1.accept(this, argu);
      n.f2.accept(this, argu);

      userDefined ans = (userDefined) argu;

      checkingForTemporarires.put(a,MaximumcalledList[1]);

      int pro = Integer.parseInt(a);
      ans.SourceDestination.get(1).add(pro);

      if(usedForChecking[0]==2){
         checkerTo.put(pro,a);
         usedForChecking[0] = 1;
      }
      else if(usedForChecking[0]==1){
         checkingForTemporarires.put(a,pro);
      }

      return _ret;
   }

   /**
    * f0 -> "PRINT"
    * f1 -> SimpleExp()
    */
   public R visit(PrintStmt n, A argu) {

      R _ret = null;

      usedForChecking[2] = 2;

      Set<Integer> thop = new HashSet<Integer> ();

      checkingForTemporarires.put("v0",2);

      thop.add(MaximumcalledList[3]+1);
       
       if(usedForChecking[0]==2){
          checkerTo.put(MaximumcalledList[3],"Main");
        }

      variableInfo.get(0).put(MaximumcalledList[3],thop);

       if(usedForChecking[3]==4){
           checkerTo.put(4,"v1");
       }

      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      
      return _ret;
   }

   /**
    * f0 -> Call()
    *       | HAllocate()
    *       | BinOp()
    *       | SimpleExp()
    */
   public R visit(Exp n, A argu) {
      R _ret = null;
 
      checkerTo.put(MaximumcalledList[3],"Call");

      n.f0.accept(this, argu);
 
      if(usedForChecking[3] == 2){
        checkingForTemporarires.put("a0",4);
        checkingForTemporarires.put("a0",MaximumcalledList[3]+1);
      }

      return _ret;
   }

   /**
    * f0 -> "BEGIN"
    * f1 -> StmtList()
    * f2 -> "RETURN"
    * f3 -> SimpleExp()
    * f4 -> "END"
    */
   public R visit(StmtExp n, A argu) {
      R _ret=null;


      checkingForTemporarires.put(" BEGIN ",MaximumcalledList[3]);

      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
  
      checkingForTemporarires.put("RETURN",MaximumcalledList[3]);
       

      Set<Integer> hi = new HashSet<Integer> ();

      hi.add(-1);

      checkingForTemporarires.put("v0",MaximumcalledList[2]);

      MaximumcalledList[3]++;


      variableInfo.get(0).put(MaximumcalledList[3],hi);

      checkerTo.put(MaximumcalledList[3],"t9");

      Set<Integer> temp = new HashSet<Integer>();

      variableInfo.get(2).put(MaximumcalledList[3],temp);
      variableInfo.get(1).put(MaximumcalledList[3],temp);
     

      userDefined ans = new userDefined();

      checkerTo.put(MaximumcalledList[5],"END");

      ans.SourceDestination.put(0,temp);
      ans.SourceDestination.put(1,temp);

      if(usedForChecking[3] == 2){
        checkingForTemporarires.put("t0",4);
        checkingForTemporarires.put("t0",MaximumcalledList[3]+1);
      }

      argu=(A)ans;
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);

      usedForChecking[0] = 4;

      return _ret;
   }

   /**
    * f0 -> "CALL"
    * f1 -> SimpleExp()
    * f2 -> "("
    * f3 -> ( Temp() )*
    * f4 -> ")"
    */
   public R visit(Call n, A argu) {
      R _ret=null;

      if(usedForChecking[5] == 2){
        checkingForTemporarires.put("a0",4);
        checkingForTemporarires.put("a1",MaximumcalledList[3]);
      }

      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);

      R thop = n.f3.accept(this, argu);

      MaximumcalledList[1]++;

      userDefined ans =(userDefined) argu;

      if(thop != null){
          LinkedList<R> parameterRegisters = (LinkedList<R>) thop;
          
          checkingForTemporarires.put("a0",parameterRegisters.size()+1);

          if(parameterRegisters.size() >= (MaximumcalledList[0]+1)){
                MaximumcalledList[0] = parameterRegisters.size();
          }
          Iterator<R> it = parameterRegisters.iterator();
          while(it.hasNext()){
              checkerTo.put(MaximumcalledList[4],"a"+MaximumcalledList[1]);
              int pro = Integer.parseInt((String)it.next());
              ans.SourceDestination.get(0).add(pro);
          }
      }

      usedForChecking[0] = 2;

      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "HALLOCATE"
    * f1 -> SimpleExp()
    */
   public R visit(HAllocate n, A argu) {
      R _ret=null;
      checkerTo.put(MaximumcalledList[3],"HALLOCATE");
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Operator()
    * f1 -> Temp()
    * f2 -> SimpleExp()
    */
   public R visit(BinOp n, A argu) {
      R _ret=null;

      if(usedForChecking[8] == 2){
          checkerTo.put(0,"Operator");
      }

      n.f0.accept(this, argu);

      String thop = (String)n.f1.accept(this, argu);

      userDefined ans = (userDefined) argu;

      checkingForTemporarires.put(thop,MaximumcalledList[3]);

      int pro = Integer.parseInt(thop);
      ans.SourceDestination.get(0).add(pro);

      if(usedForChecking[3]==4){
           checkingForTemporarires.put("t2",4);
       }

      n.f2.accept(this, argu);

      checkingForTemporarires.put("Operator",MaximumcalledList[3]);
      return _ret;
   }

   /**
    * f0 -> "LE"
    *       | "NE"
    *       | "PLUS"
    *       | "MINUS"
    *       | "TIMES"
    *       | "DIV"
    */
   public R visit(Operator n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Temp()
    *       | IntegerLiteral()
    *       | Label()
    */
   public R visit(SimpleExp n, A argu) {
      R _ret=null;
    
      if(usedForChecking[7] == 2){
         checkingForTemporarires.put("TEMP",MaximumcalledList[4]);
      }

      R thop = n.f0.accept(this, argu);

      if(n.f0.which==0){
          userDefined ans = (userDefined) argu;
      
          checkingForTemporarires.put("TEMP",MaximumcalledList[1]);

          int pro = Integer.parseInt((String)thop);
          ans.SourceDestination.get(0).add(pro);
  
          checkerTo.put(MaximumcalledList[3],(String)thop);

          return thop;
      } 
      else if(n.f0.which==2){

        checkerTo.put(MaximumcalledList[2],(String)thop);
        return thop;
      } 

      checkerTo.put(MaximumcalledList[2],(String)thop);

      return _ret;
   }

   /**
    * f0 -> "TEMP"
    * f1 -> IntegerLiteral()
    */
   public R visit(Temp n, A argu) {
      R _ret=null;
      MaximumcalledList[4]++;
      n.f0.accept(this, argu);
      String thop = (String)n.f1.accept(this, argu);
     
      checkingForTemporarires.put(thop,MaximumcalledList[3]);

      return (R)thop;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n, A argu) {
      R _ret=null;
 
      MaximumcalledList[5]++;

      n.f0.accept(this, argu);

      checkingForTemporarires.put((String)n.f0.toString(),MaximumcalledList[3]);
      
      return (R)n.f0.toString() ;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Label n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return (R) n.f0.toString();
   }

}
